
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>main</title><meta name="generator" content="MATLAB 9.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-05-05"><meta name="DC.source" content="main.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Piano Note Decoding: Lab P-14: 5 Lab Exercise</a></li><li><a href="#2">5</a></li><li><a href="#3">5.1a</a></li><li><a href="#4">5.1b</a></li><li><a href="#5">5.2</a></li><li><a href="#6">5.2a.a</a></li><li><a href="#7">5.2a.b</a></li><li><a href="#8">5.2b and 5.2c</a></li><li><a href="#9">5.2d</a></li><li><a href="#10">5.3</a></li><li><a href="#11">5.3a</a></li><li><a href="#12">5.3b and 5.3c</a></li><li><a href="#13">5.3d</a></li><li><a href="#14">5.3e</a></li></ul></div><h2 id="1">Piano Note Decoding: Lab P-14: 5 Lab Exercise</h2><pre class="codeinput">clc
clear
close <span class="string">all</span>
</pre><h2 id="2">5</h2><pre class="codeinput">idx = 1:5;  <span class="comment">% 5 filters</span>
</pre><h2 id="3">5.1a</h2><p>lower normalized radial frequency of the octave</p><pre class="codeinput">lowRad = ones(length(idx), 1);
<span class="comment">% the lowest octave starts at key 16</span>
<span class="comment">% Key 49 is 440 Hz, so 440*2^((16-49)/12) is the frequency of key 16</span>
lowRad(1) = 440*2^((16-49)/12) / 8000 * 2 * pi;
<span class="keyword">for</span> k = 2:5
    <span class="comment">% each octave is double the previous</span>
    lowRad(k) = lowRad(k-1) * 2;
<span class="keyword">end</span>
<span class="comment">% the high end of the octave is double the low</span>
highRad = 2.*lowRad;
<span class="comment">% low end frequencies in Hertz</span>
lowHertz = lowRad / 2 / pi;
<span class="comment">% high end frequencies in Hertz</span>
highHertz = highRad / 2 / pi;
</pre><h2 id="4">5.1b</h2><p>the center point of the octave</p><pre class="codeinput">centerRad  = sqrt(lowRad .* highRad);
<span class="comment">% the center in Hertz</span>
centerHertz = centerRad / 2 / pi;

fprintf(<span class="string">"Octave\t\tLower Edge(Hz)\t\tHigh Edge(Hz)\t\tCenter(Hz) \n"</span>);
<span class="keyword">for</span> i = 1:5
fprintf(<span class="string">"%d\t\t%f\t\t%f\t\t%f\n"</span>, i+1, lowHertz(i), highHertz(i), centerHertz(i));
<span class="keyword">end</span>
fprintf(<span class="string">"\n"</span>);
fprintf(<span class="string">"Octave\t\tLower Edge(rad)\t\tHigh Edge(rad)\t\tCenter(rad) \n"</span>);
<span class="keyword">for</span> i = 1:5
fprintf(<span class="string">"%d\t\t%f\t\t%f\t\t%f\n"</span>, i+1, lowRad(i), highRad(i), centerRad(i));
<span class="keyword">end</span>
</pre><pre class="codeoutput">Octave		Lower Edge(Hz)		High Edge(Hz)		Center(Hz) 
2		0.008176		0.016352		0.011562
3		0.016352		0.032703		0.023125
4		0.032703		0.065406		0.046249
5		0.065406		0.130813		0.092499
6		0.130813		0.261626		0.184997

Octave		Lower Edge(rad)		High Edge(rad)		Center(rad) 
2		0.051370		0.102740		0.072648
3		0.102740		0.205480		0.145296
4		0.205480		0.410960		0.290593
5		0.410960		0.821921		0.581186
6		0.821921		1.643842		1.162372
</pre><h2 id="5">5.2</h2><h2 id="6">5.2a.a</h2><p>the instructions say this is nearly impossible</p><h2 id="7">5.2a.b</h2><p>see the lines surrounding the HH variable for scaling of the filters</p><h2 id="8">5.2b and 5.2c</h2><p>The BWL ratio is used to calculate L according to L = BWL / Bandwidth</p><pre class="codeinput">BWL = 0.141372 * 81;
<span class="comment">% x axis in our plots</span>
ww = 0:(pi/1000):pi;
<span class="comment">% calculate L for filters</span>
L = BWL ./ (highRad - lowRad);
<span class="comment">% hamming windows, each will be of different lengths</span>
windows = cell(length(idx),1);


figure
title(<span class="string">"Magnitude Reponse Octaves 2 through 6"</span>);
xlabel(<span class="string">"\omega"</span>);
ylabel(<span class="string">"|H|"</span>);
hold <span class="string">on</span>;
<span class="keyword">for</span> i = idx
    <span class="comment">% calculate the window using wc and L</span>
    windows{i} = gen_hamming(centerRad(i),round(L(i)));
    <span class="comment">% calculate magnitude and phase response of h</span>
    HH = freqz(windows{i}, 1, ww);
    <span class="comment">% normalize the coefficients such that the max is 1</span>
    windows{i} = windows{i} ./ max(HH);
    <span class="comment">% recalculate HH using normalized coefficients</span>
    HH = freqz(windows{i}, 1, ww);
    <span class="comment">% plot magnitude, use ww / 2 / pi * 8000 for frequency on x axis</span>
    plot(ww / 2 / pi * 8000, abs(HH));
<span class="keyword">end</span>
plot(centerHertz * 8000, ones(i, 1), <span class="string">'o'</span>);
legend(<span class="string">'octave 2'</span>, <span class="string">'octave 3'</span>, <span class="string">'octave 4'</span>, <span class="string">'octave 5'</span>, <span class="string">'octave 6'</span>, <span class="string">'Center Frequencies'</span>);
hold <span class="string">off</span>

WW = 0:pi/1000:pi;      <span class="comment">% frequency range</span>
figure
title(<span class="string">"Phase Reponse Octaves 2 through 6"</span>);
xlabel(<span class="string">"\omega"</span>);
ylabel(<span class="string">"theta"</span>);
hold <span class="string">on</span>;
<span class="keyword">for</span> i = idx
    <span class="comment">% calculate the window using wc and L</span>
    windows{i} = gen_hamming(centerRad(i),round(L(i)));
    <span class="comment">% calculate magnitude and phase response of h</span>
    HH = freqz(windows{i}, 1, ww);
    <span class="comment">% normalize the coefficients such that the max is 1</span>
    windows{i} = windows{i} ./ max(HH);
    <span class="comment">% recalculate HH using normalized coefficients</span>
    HH = freqz(windows{i}, 1, ww);
    <span class="comment">% plot magnitude, use ww / 2 / pi * 8000 for frequency on x axis</span>
    <span class="comment">%plot(ww / 2 / pi * 8000, abs(HH));</span>
    plot(angle(HH));
<span class="keyword">end</span>
<span class="comment">%plot(centerHertz * 8000, ones(i, 1), 'o');</span>
legend(<span class="string">'octave 2'</span>, <span class="string">'octave 3'</span>, <span class="string">'octave 4'</span>, <span class="string">'octave 5'</span>, <span class="string">'octave 6'</span>);
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="main_01.png" alt=""> <img vspace="5" hspace="5" src="main_02.png" alt=""> <h2 id="9">5.2d</h2><p>yes the filter's passbands are narrow enough however, there is non-zero area where the magnitude response is below 0.5 yet above 0</p><h2 id="10">5.3</h2><h2 id="11">5.3a</h2><p>number of points in xx</p><pre class="codeinput">N = 0.85*8000;
<span class="comment">% x(t)</span>
xx = zeros(N,1);
<span class="comment">% t</span>
t = zeros(N,1);
<span class="keyword">for</span> i = 1:N
    t(i) = i/8000;
<span class="keyword">end</span>
<span class="comment">% first segment goes to 0.25 seconds</span>
<span class="keyword">for</span> i = 1:round(0.25*8000)
    <span class="comment">% formula for first segment</span>
    xx(i) = cos(2*pi*220*i / 8000);
<span class="keyword">end</span>
<span class="comment">% zero in between</span>
<span class="keyword">for</span> i = round(0.25*8000) + 1:round(0.30*8000)
    xx(i) = 0;
<span class="keyword">end</span>
<span class="comment">% second segment goes from 0.30 to 0.55</span>
<span class="keyword">for</span> i = round(0.30*8000) + 1:round(0.55*8000)
    <span class="comment">% formula for second segment</span>
    xx(i) = cos(2*pi*880*i / 8000);
<span class="keyword">end</span>
<span class="comment">% zero in between</span>
<span class="keyword">for</span> i = round(0.55*8000) + 1:round(0.60*8000)
    xx(i) = 0;
<span class="keyword">end</span>
<span class="comment">% third segment goes from 0.60 to 0.85</span>
<span class="keyword">for</span> i = round(0.60*8000) + 1:round(0.85*8000)
    <span class="comment">% formula for third segment</span>
    xx(i) = cos(2*pi*440*i / 8000) + cos(2*pi*1760*i / 8000);
<span class="keyword">end</span>
</pre><h2 id="12">5.3b and 5.3c</h2><p>matrix of outputs</p><pre class="codeinput">output = zeros(length(xx), length(windows));
figure

<span class="keyword">for</span> i = idx
    <span class="comment">% calculate output using convolution</span>
    yy = conv(windows{i}, xx);
    <span class="comment">% cut off the first L elements of the convolution</span>
    output(:, i) = yy(round(L(i)):end);
    subplot(length(idx),1,i);
    <span class="comment">% plot the output</span>
    plot(t, abs(output(:,i)));
    ylim([0,1])
<span class="keyword">end</span>
sgtitle(<span class="string">'Magnitude'</span>)

<span class="comment">% matrix of outputs</span>
output = zeros(length(xx), length(windows));
figure

<span class="keyword">for</span> i = idx
    <span class="comment">% calculate output using convolution</span>
    yy = conv(windows{i}, xx);
    <span class="comment">% cut off the first L elements of the convolution</span>
    output(:, i) = yy(round(L(i)):end);
    subplot(length(idx),1,i);
    <span class="comment">% plot the output</span>
    plot(t, angle(output(:,i)));
    ylim([0,1])
<span class="keyword">end</span>
sgtitle(<span class="string">'Phase'</span>)
</pre><img vspace="5" hspace="5" src="main_03.png" alt=""> <img vspace="5" hspace="5" src="main_04.png" alt=""> <h2 id="13">5.3d</h2><p>Yes, the output signals have the correct magnitude and phase</p><h2 id="14">5.3e</h2><p>The transient time for the second lowest filter is 0.0142s The transient time for the third lowest filter is 0.006s The transient time for the fourth lowest filter is 0.004s The transient time for the fifth lowest filter is 0.0015s</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Piano Note Decoding: Lab P-14: 5 Lab Exercise
clc 
clear
close all

%% 5
idx = 1:5;  % 5 filters
    
%% 5.1a
% lower normalized radial frequency of the octave
lowRad = ones(length(idx), 1);
% the lowest octave starts at key 16   
% Key 49 is 440 Hz, so 440*2^((16-49)/12) is the frequency of key 16
lowRad(1) = 440*2^((16-49)/12) / 8000 * 2 * pi;
for k = 2:5
    % each octave is double the previous
    lowRad(k) = lowRad(k-1) * 2;
end
% the high end of the octave is double the low
highRad = 2.*lowRad;
% low end frequencies in Hertz
lowHertz = lowRad / 2 / pi;
% high end frequencies in Hertz
highHertz = highRad / 2 / pi;
%% 5.1b
% the center point of the octave 
centerRad  = sqrt(lowRad .* highRad);
% the center in Hertz
centerHertz = centerRad / 2 / pi;

fprintf("Octave\t\tLower Edge(Hz)\t\tHigh Edge(Hz)\t\tCenter(Hz) \n");
for i = 1:5
fprintf("%d\t\t%f\t\t%f\t\t%f\n", i+1, lowHertz(i), highHertz(i), centerHertz(i));
end
fprintf("\n");
fprintf("Octave\t\tLower Edge(rad)\t\tHigh Edge(rad)\t\tCenter(rad) \n");
for i = 1:5
fprintf("%d\t\t%f\t\t%f\t\t%f\n", i+1, lowRad(i), highRad(i), centerRad(i));
end

%% 5.2

%% 5.2a.a
% the instructions say this is nearly impossible
%% 5.2a.b
% see the lines surrounding the HH variable for scaling of the filters
%% 5.2b and 5.2c
% The BWL ratio is used to calculate L according to L = BWL / Bandwidth
BWL = 0.141372 * 81;
% x axis in our plots
ww = 0:(pi/1000):pi;
% calculate L for filters
L = BWL ./ (highRad - lowRad);
% hamming windows, each will be of different lengths
windows = cell(length(idx),1);


figure
title("Magnitude Reponse Octaves 2 through 6");
xlabel("\omega");
ylabel("|H|");
hold on;
for i = idx
    % calculate the window using wc and L
    windows{i} = gen_hamming(centerRad(i),round(L(i)));
    % calculate magnitude and phase response of h
    HH = freqz(windows{i}, 1, ww);
    % normalize the coefficients such that the max is 1
    windows{i} = windows{i} ./ max(HH);
    % recalculate HH using normalized coefficients
    HH = freqz(windows{i}, 1, ww);
    % plot magnitude, use ww / 2 / pi * 8000 for frequency on x axis
    plot(ww / 2 / pi * 8000, abs(HH));
end
plot(centerHertz * 8000, ones(i, 1), 'o');
legend('octave 2', 'octave 3', 'octave 4', 'octave 5', 'octave 6', 'Center Frequencies');
hold off

WW = 0:pi/1000:pi;      % frequency range
figure
title("Phase Reponse Octaves 2 through 6");
xlabel("\omega");
ylabel("theta");
hold on;
for i = idx
    % calculate the window using wc and L
    windows{i} = gen_hamming(centerRad(i),round(L(i)));
    % calculate magnitude and phase response of h
    HH = freqz(windows{i}, 1, ww);
    % normalize the coefficients such that the max is 1
    windows{i} = windows{i} ./ max(HH);
    % recalculate HH using normalized coefficients
    HH = freqz(windows{i}, 1, ww);
    % plot magnitude, use ww / 2 / pi * 8000 for frequency on x axis
    %plot(ww / 2 / pi * 8000, abs(HH));
    plot(angle(HH));
end
%plot(centerHertz * 8000, ones(i, 1), 'o');
legend('octave 2', 'octave 3', 'octave 4', 'octave 5', 'octave 6');
hold off

%% 5.2d
% yes the filter's passbands are narrow enough
% however, there is non-zero area where the magnitude response is below 0.5
% yet above 0
%% 5.3

%% 5.3a
% number of points in xx
N = 0.85*8000;
% x(t)
xx = zeros(N,1);
% t
t = zeros(N,1);
for i = 1:N
    t(i) = i/8000;
end
% first segment goes to 0.25 seconds
for i = 1:round(0.25*8000)
    % formula for first segment
    xx(i) = cos(2*pi*220*i / 8000);
end
% zero in between
for i = round(0.25*8000) + 1:round(0.30*8000)
    xx(i) = 0;
end
% second segment goes from 0.30 to 0.55
for i = round(0.30*8000) + 1:round(0.55*8000)
    % formula for second segment
    xx(i) = cos(2*pi*880*i / 8000);
end
% zero in between
for i = round(0.55*8000) + 1:round(0.60*8000)
    xx(i) = 0;
end
% third segment goes from 0.60 to 0.85
for i = round(0.60*8000) + 1:round(0.85*8000)
    % formula for third segment
    xx(i) = cos(2*pi*440*i / 8000) + cos(2*pi*1760*i / 8000);
end
%% 5.3b and 5.3c
% matrix of outputs
output = zeros(length(xx), length(windows));
figure

for i = idx
    % calculate output using convolution
    yy = conv(windows{i}, xx);
    % cut off the first L elements of the convolution
    output(:, i) = yy(round(L(i)):end);
    subplot(length(idx),1,i);
    % plot the output
    plot(t, abs(output(:,i)));
    ylim([0,1])
end
sgtitle('Magnitude')

% matrix of outputs
output = zeros(length(xx), length(windows));
figure

for i = idx
    % calculate output using convolution
    yy = conv(windows{i}, xx);
    % cut off the first L elements of the convolution
    output(:, i) = yy(round(L(i)):end);
    subplot(length(idx),1,i);
    % plot the output
    plot(t, angle(output(:,i)));
    ylim([0,1])
end
sgtitle('Phase')

%% 5.3d
% Yes, the output signals have the correct magnitude and phase
%% 5.3e
% The transient time for the second lowest filter is 0.0142s
% The transient time for the third lowest filter is 0.006s
% The transient time for the fourth lowest filter is 0.004s
% The transient time for the fifth lowest filter is 0.0015s
##### SOURCE END #####
--></body></html>